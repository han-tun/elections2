---
title: "Maps"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{maps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(elections2)
knitr::opts_chunk$set(error = TRUE)
```

This package has two convenience functions for turning wrangled election results into interactive Leaflet maps. You will need to have a shapefile of your election districts (precincts, cities, etc.) as well as election results. It is up to you to import the shapefile with geospatial district data into R and then join it with a data frame of election results generated by the `wrangle_results()` function. 

The `map_election_results()` function generates a map with one color for each candidate. Color intensity depends on the value of percent or total number of votes won in each district.

`map_election_results_2layers()` puts each candidate's results on a different map layer.


### Example 1 - City Precincts

Import your election results with the wrangle_results(results_file) if you haven't already. Make sure to remove the Total row, since the shapefile and map won't have them.
```{r}

results_file <- system.file("extdata", "FakeElectionResults.xlsx", package = "elections2")

my_election_data <- wrangle_results(results_file) %>%
  dplyr::filter(Precinct != "Total")
head(my_election_data)

```

To make a map, you'll need to import a shapefile of your election districts -- precincts, cities, counties, states, etc. -- into R using the sf package's `st_read()` function. This example imports precinct shapefiles for the city of Framingham, Massachusetts.

```{r import_shapefile, message=FALSE, echo=FALSE}
my_shapefile <- system.file("extdata", "FraminghamDistrictsAndPrecincts2018/framingham.shp", package = "elections2")


my_geometry <- sf::st_read(my_shapefile, quiet = TRUE)


```


_Make sure you have a common column in election data and the GIS file that use identical values for your election districts._


You can use any number of ways to check if two vectors are identical. I'm using testthat::expect_equal() because it gives some explanations if the two objects aren't equal. Base R `identical()` just shows TRUE or FALSE.


```{r datacheck}
testthat::expect_equal(
  (sort(my_election_data$Precinct)), 
  sort(my_geometry$precinct)
)

```

In this data set, I need to either get rid of the "P" in the geometry or add it to my results. I'll get rid of it in the geometry and turn these into ordered factors so they sort correctly in a table or graph. What _you_ need to do in this step, if anything, will depend on your specific election-district data.

```{r string2orderedfactor}

my_geometry$precinct <- gsub("P", "", my_geometry$precinct)


testthat::expect_equal(
  (sort(my_election_data$Precinct)), 
  sort(my_geometry$precinct)
)


```

Once I'm sure I have identical column values for my election districts, I can join the geometry with the results using `merge()`. If the first argument is an sf geospatial object and the second argument is a 'regular' data frame, the result witll be an sf object.

```{r join_data, warning=FALSE}

election_results_for_map <- merge(my_geometry, my_election_data, by.x = "precinct", by.y = "Precinct") 
class(election_results_for_map)
```

I'm also going to change the name of the resulting district column from precinct to Precinct so it will show better on the map. 

```{r}
names(election_results_for_map)[1] <- "Precinct"
```


Now I can use the map_election_results() function. Note that I need to specify the names of the winner column and loser column in the win_col and lose_col arguments.

```{r map1, fig.width=7, fig.height=7}

map_election_results(election_results_for_map, win_col = "Yes_Pct", lose_col = "No_Pct", election_district_col = "Precinct", "Greens", "Purples")

```


### Example 2 - Cities and Towns Statewide

This next example will look at results by city/town in Massachusetts for the ballot question legalizing recreational marijuana use.

Import results:

```{r}
results_file2 <- system.file("extdata", "2016_Statewide_Question_4_marijuana.csv", package = "elections2")

my_election_data2 <- wrangle_results(results_file2)


```

For this CSV file from the Secretary of State's office, I removed the commas from the numerical columns and also deleted columns for blanks and totals, since I just want to see Yes vs No.

```{r}
head(my_election_data2)
```

Next I need a shapefile for Massachusetts cities and towns, which I found on the [Massachusetts GIS website](https://docs.digital.mass.gov/dataset/massgis-data-community-boundaries-towns-survey-points). I already imported it into R, turned the place names to Title Case, and re-projected it so it matches the underlying Leaflet basemap. It is included in this package as the R sf object `mass_gis`.

However, I still need to make sure that names of communities in the _election results data_ match those in the _GIS data_. dplyr's `anti_join()` will show me which items in my_election_data2 don't have a match:

```{r}

dplyr::anti_join(my_election_data2, mass_gis, by = c("Locality" = "Place"))

```

Looks like I need to spell out North, South, East, and West:

```{r}
my_election_data2 <- my_election_data2 %>%
  dplyr::mutate(
    Locality = stringr::str_replace(Locality, "N\\.", "North"),
    Locality = stringr::str_replace(Locality, "S\\.", "South"),
    Locality = stringr::str_replace(Locality, "E\\.", "East"),
    Locality = stringr::str_replace(Locality, "W\\.", "West"),
  )

dplyr::anti_join(my_election_data2, mass_gis, by = c("Locality" = "Place"))


```

I'll deal with these last two:

```{r}
my_election_data2 <- my_election_data2 %>%
  dplyr::mutate(
    Locality = stringr::str_replace(Locality, "Manchester-by-the-Sea", "Manchester")
  ) %>%
  dplyr::filter(Locality != "Total")



```

You'll almost always need to do fiddling like this to match your place names in election data with place names in maps.

Now to join election results with the shapefile:

```{r}
marijuana_results_for_map <- merge(mass_gis, my_election_data2, by.x = "Place", by.y = "Locality") 
```

And, finally, this package's 


```{r warning=FALSE, message=FALSE}
map_election_results(marijuana_results_for_map, win_col = "Yes_Pct", lose_col = "No_Pct", election_district_col = "Place", "Greens", "Purples")
```

For mapping turnout, see the `map_turnout()` function and the Mapping Turnout vignette.
